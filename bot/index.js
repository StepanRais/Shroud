const { Telegraf } = require("telegraf");
const axios = require("axios");
const FormData = require("form-data");
require("dotenv").config();

const bot = new Telegraf(process.env.TELEGRAM_BOT_TOKEN);
const userStates = {};

// –§—É–Ω–∫—Ü–∏—è –¥–ª—è —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –ø–æ–¥–ø–∏—Å—á–∏–∫–æ–≤
async function notifySubscribers(product) {
  try {
    console.log("Notifying subscribers about product:", product);
    const response = await axios.get(
      "https://shroud.onrender.com/api/subscribers"
    );
    const subscribers = response.data;
    console.log("Found subscribers:", subscribers);
    if (subscribers.length === 0) {
      console.log("No subscribers found");
      return;
    }
    for (const subscriber of subscribers) {
      console.log(`Sending message to user ${subscriber.userId}`);
      await bot.telegram.sendMessage(
        subscriber.userId,
        `–ù–æ–≤–æ–µ –ø–æ—Å—Ç—É–ø–ª–µ–Ω–∏–µ "${product.category}" "${product.name}"`
      );
    }
    console.log("Notifications sent successfully");
  } catch (error) {
    console.error("Error sending notifications:", error.message);
    if (error.response) {
      console.error("Response status:", error.response.status);
      console.error("Response data:", error.response.data);
    }
  }
}

// –õ–æ–≥–∏–∫–∞ –±–æ—Ç–∞
bot.start((ctx) => {
  console.log("Start command received from user:", ctx.from.id);
  ctx.reply("–î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å –≤ –º–∞–≥–∞–∑–∏–Ω –º–µ—Ä—á–∞! üòé", {
    reply_markup: {
      inline_keyboard: [
        [
          {
            text: "–û—Ç–∫—Ä—ã—Ç—å –º–∞–≥–∞–∑–∏–Ω üõí",
            web_app: { url: "https://shroud.onrender.com" },
          },
        ],
        [{ text: "–û—Å—Ç–∞–≤–∏—Ç—å –æ—Ç–∑—ã–≤ ‚≠ê", callback_data: "leave_review" }],
        [{ text: "–ü–æ–¥–ø–∏—Å–∞—Ç—å—Å—è –Ω–∞ —Ä–∞—Å—Å—ã–ª–∫—É üì¨", callback_data: "subscribe" }],
        [{ text: "–û—Ç–ø–∏—Å–∞—Ç—å—Å—è –æ—Ç —Ä–∞—Å—Å—ã–ª–∫–∏ üì¥", callback_data: "unsubscribe" }],
        [{ text: "–°–æ–∑–¥–∞—Ç—å –∞–Ω–∫–µ—Ç—É üìù", callback_data: "create_form" }],
        [{ text: "–ù–∞—à –∫–∞–Ω–∞–ª üì¢", callback_data: "visit_channel" }],
      ],
      remove_keyboard: true,
    },
  });
});

bot.action("open_shop", (ctx) => {
  console.log("Opening shop for user:", ctx.from.id);
  ctx.reply("–û—Ç–∫—Ä—ã–≤–∞–µ–º –º–∞–≥–∞–∑–∏–Ω...", {
    reply_markup: {
      inline_keyboard: [
        [
          {
            text: "–û—Ç–∫—Ä—ã—Ç—å –º–∞–≥–∞–∑–∏–Ω üõí",
            web_app: { url: "https://shroud.onrender.com" },
          },
        ],
      ],
    },
  });
});

bot.action("leave_review", (ctx) => {
  console.log("User wants to leave review:", ctx.from.id);
  userStates[ctx.from.id] = { state: "waiting_for_review" };
  ctx.reply("–ù–∞–ø–∏—à–∏—Ç–µ –≤–∞—à –æ—Ç–∑—ã–≤:", { reply_markup: { force_reply: true } });
});

bot.action("subscribe", async (ctx) => {
  console.log("Subscription request from user:", ctx.from.id);
  try {
    const response = await axios.get(
      "https://shroud.onrender.com/api/subscribers"
    );
    const subscribers = response.data;
    if (subscribers.some((sub) => sub.userId === ctx.from.id)) {
      ctx.reply("–í—ã —É–∂–µ –ø–æ–¥–ø–∏—Å–∞–Ω—ã –Ω–∞ —Ä–∞—Å—Å—ã–ª–∫—É! üì¨");
      return;
    }
    await axios.post("https://shroud.onrender.com/api/subscribers", {
      userId: ctx.from.id,
    });
    ctx.reply("–í—ã –ø–æ–¥–ø–∏—Å–∞–ª–∏—Å—å –Ω–∞ —Ä–∞—Å—Å—ã–ª–∫—É! üì¨");
  } catch (error) {
    console.error("Error subscribing:", error.message);
    ctx.reply("–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–¥–ø–∏—Å–∫–µ. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ.");
  }
});

bot.action("unsubscribe", async (ctx) => {
  console.log("Unsubscription request from user:", ctx.from.id);
  try {
    await axios.delete(
      `https://shroud.onrender.com/api/subscribers/${ctx.from.id}`
    );
    ctx.reply("–í—ã –æ—Ç–ø–∏—Å–∞–ª–∏—Å—å –æ—Ç —Ä–∞—Å—Å—ã–ª–∫–∏! üì¥");
  } catch (error) {
    console.error("Error unsubscribing:", error.message);
    ctx.reply("–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–ø–∏—Å–∫–µ. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ.");
  }
});

bot.action("create_form", (ctx) => {
  console.log("User wants to create form:", ctx.from.id);
  userStates[ctx.from.id] = { state: "waiting_for_photo", photos: [] };
  ctx.reply(
    "–û—Ç–ø—Ä–∞–≤—å—Ç–µ —Ñ–æ—Ç–æ —Ç–æ–≤–∞—Ä–∞ (–º–æ–∂–Ω–æ –Ω–µ—Å–∫–æ–ª—å–∫–æ). –ö–æ–≥–¥–∞ –∑–∞–∫–æ–Ω—á–∏—Ç–µ, –Ω–∞–ø–∏—à–∏—Ç–µ '–ì–æ—Ç–æ–≤–æ'."
  );
});

bot.action("visit_channel", (ctx) => {
  console.log("User wants to visit channel:", ctx.from.id);
  ctx.reply("–ü–æ–¥–ø–∏—Å—ã–≤–∞–π—Ç–µ—Å—å –Ω–∞ –Ω–∞—à –∫–∞–Ω–∞–ª: https://t.me/your_channel");
});

bot.action(/approve_review_(.+)/, async (ctx) => {
  const reviewId = ctx.match[1];
  try {
    console.log("Approving review:", reviewId);
    await axios.put(
      `https://shroud.onrender.com/api/reviews/${reviewId}/approve`
    );
    ctx.reply("–û—Ç–∑—ã–≤ –æ–¥–æ–±—Ä–µ–Ω!");
    await ctx.editMessageReplyMarkup({ reply_markup: { inline_keyboard: [] } });
  } catch (error) {
    console.error("Error approving review:", error.message);
    ctx.reply("–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–¥–æ–±—Ä–µ–Ω–∏–∏ –æ—Ç–∑—ã–≤–∞.");
  }
});

bot.action(/reject_review_(.+)/, async (ctx) => {
  const reviewId = ctx.match[1];
  try {
    console.log("Rejecting review:", reviewId);
    await axios.delete(`https://shroud.onrender.com/api/reviews/${reviewId}`);
    ctx.reply("–û—Ç–∑—ã–≤ –æ—Ç–∫–ª–æ–Ω—ë–Ω!");
    await ctx.editMessageReplyMarkup({ reply_markup: { inline_keyboard: [] } });
  } catch (error) {
    console.error("Error rejecting review:", error.message);
    ctx.reply("–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–∫–ª–æ–Ω–µ–Ω–∏–∏ –æ—Ç–∑—ã–≤–∞.");
  }
});

bot.on("photo", async (ctx) => {
  const userId = ctx.from.id;
  const state = userStates[userId]?.state;

  if (state === "waiting_for_photo") {
    try {
      console.log("Photos received from user:", userId);
      const photos = ctx.message.photo;
      for (const photo of photos) {
        const fileUrl = await bot.telegram.getFileLink(photo.file_id);
        const response = await axios.get(fileUrl, {
          responseType: "arraybuffer",
        });
        const base64String = `data:image/jpeg;base64,${Buffer.from(
          response.data
        ).toString("base64")}`;
        userStates[userId].photos.push(base64String);
      }
      ctx.reply("–§–æ—Ç–æ –¥–æ–±–∞–≤–ª–µ–Ω–æ. –ü—Ä–∏—à–ª–∏—Ç–µ –µ—â—ë –∏–ª–∏ –Ω–∞–ø–∏—à–∏—Ç–µ '–ì–æ—Ç–æ–≤–æ'.");
    } catch (error) {
      console.error("Error processing photo:", error.message);
      ctx.reply("–û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ —Ñ–æ—Ç–æ. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞.");
    }
  }
});

bot.on("web_app_data", async (ctx) => {
  try {
    console.log("Web app data received from user:", ctx.from.id);
    const data = JSON.parse(ctx.webAppData.data);
    if (data.action === "requestPayment") {
      const { total, delivery, items } = data;
      let message = `–ù–æ–≤—ã–π –∑–∞–∫–∞–∑:\n–§–ò–û: ${delivery.name}\n–ê–¥—Ä–µ—Å: ${delivery.address}\n–¢–µ–ª–µ—Ñ–æ–Ω: ${delivery.phone}\n\n–¢–æ–≤–∞—Ä—ã:\n`;
      items.forEach((item, index) => {
        message += `${index + 1}. ${item.name} (–†–∞–∑–º–µ—Ä: ${item.size}) - ${
          item.price
        }‚ÇΩ\n`;
      });
      message += `\n–ò—Ç–æ–≥–æ: ${total}‚ÇΩ`;
      await bot.telegram.sendMessage(process.env.ADMIN_CHAT_ID, message);
      ctx.reply("–í–∞—à –∑–∞–∫–∞–∑ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω! –ú—ã —Å–≤—è–∂–µ–º—Å—è —Å –≤–∞–º–∏ –¥–ª—è –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è.");
    }
  } catch (error) {
    console.error("Error processing web app data:", error.message);
    ctx.reply("–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ –∑–∞–∫–∞–∑–∞. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ.");
  }
});

bot.on("text", async (ctx) => {
  const userId = ctx.from.id;
  const state = userStates[userId]?.state;

  if (state === "waiting_for_review") {
    try {
      console.log("Review received from user:", userId);
      const review = {
        username: ctx.from.username || ctx.from.first_name || "–ê–Ω–æ–Ω–∏–º",
        text: ctx.message.text,
      };
      const response = await axios.post(
        "https://shroud.onrender.com/api/reviews",
        review
      );
      await bot.telegram.sendMessage(
        process.env.ADMIN_CHAT_ID,
        `–ù–æ–≤—ã–π –æ—Ç–∑—ã–≤ –æ—Ç @${
          ctx.from.username || ctx.from.first_name || "–ê–Ω–æ–Ω–∏–º"
        }:\n${ctx.message.text}`,
        {
          reply_markup: {
            inline_keyboard: [
              [
                {
                  text: "–û–¥–æ–±—Ä–∏—Ç—å",
                  callback_data: `approve_review_${response.data._id}`,
                },
                {
                  text: "–û—Ç–∫–ª–æ–Ω–∏—Ç—å",
                  callback_data: `reject_review_${response.data._id}`,
                },
              ],
            ],
          },
        }
      );
      ctx.reply("–°–ø–∞—Å–∏–±–æ –∑–∞ –≤–∞—à –æ—Ç–∑—ã–≤! –û–Ω –±—É–¥–µ—Ç –æ–ø—É–±–ª–∏–∫–æ–≤–∞–Ω –ø–æ—Å–ª–µ –ø—Ä–æ–≤–µ—Ä–∫–∏.");
    } catch (error) {
      console.error("Error saving review:", error.message);
      ctx.reply("–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–ø—Ä–∞–≤–∫–µ –æ—Ç–∑—ã–≤–∞. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ.");
    }
    delete userStates[userId];
  } else if (
    state === "waiting_for_photo" &&
    ctx.message.text.toLowerCase() === "–≥–æ—Ç–æ–≤–æ"
  ) {
    if (userStates[userId].photos.length === 0) {
      ctx.reply("–í—ã –Ω–µ –¥–æ–±–∞–≤–∏–ª–∏ –Ω–∏ –æ–¥–Ω–æ–≥–æ —Ñ–æ—Ç–æ. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –æ—Ç–ø—Ä–∞–≤—å—Ç–µ —Ñ–æ—Ç–æ.");
      return;
    }
    userStates[userId].state = "waiting_for_form_text";
    ctx.reply(
      "–í–≤–µ–¥–∏—Ç–µ –Ω–∞–∑–≤–∞–Ω–∏–µ, —Ä–∞–∑–º–µ—Ä, —Å–æ—Å—Ç–æ—è–Ω–∏–µ –∏ –∫–∞—Ç–µ–≥–æ—Ä–∏—é —Ç–æ–≤–∞—Ä–∞ (–Ω–∞–ø—Ä–∏–º–µ—Ä: –§—É—Ç–±–æ–ª–∫–∞, M, –ù–æ–≤–æ–µ, –û–¥–µ–∂–¥–∞):",
      { reply_markup: { force_reply: true } }
    );
  } else if (state === "waiting_for_form_text") {
    const [name, size, condition, category] = ctx.message.text
      .split(",")
      .map((s) => s.trim());
    const form = {
      photo: userStates[userId].photos,
      name,
      size,
      condition,
      category,
      userId: ctx.from.id,
      approved: false,
    };
    try {
      console.log("Form submitted by user:", userId);
      await axios.post("https://shroud.onrender.com/api/forms", form);
      const mediaGroup = userStates[userId].photos.map((photo) => ({
        type: "photo",
        media: { source: Buffer.from(photo.split(",")[1], "base64") },
      }));
      if (mediaGroup.length > 0) {
        await bot.telegram.sendMediaGroup(
          process.env.ADMIN_CHAT_ID,
          mediaGroup
        );
      }
      await bot.telegram.sendMessage(
        process.env.ADMIN_CHAT_ID,
        `–ù–æ–≤–∞—è –∞–Ω–∫–µ—Ç–∞ –æ—Ç @${
          ctx.from.username || ctx.from.first_name || "–ê–Ω–æ–Ω–∏–º"
        }:\n–ù–∞–∑–≤–∞–Ω–∏–µ: ${name}\n–†–∞–∑–º–µ—Ä: ${size}\n–°–æ—Å—Ç–æ—è–Ω–∏–µ: ${condition}\n–ö–∞—Ç–µ–≥–æ—Ä–∏—è: ${category}\n–§–æ—Ç–æ: ${
          userStates[userId].photos.length
        } —à—Ç.`
      );
      ctx.reply("–ê–Ω–∫–µ—Ç–∞ –ø—Ä–∏–Ω—è—Ç–∞ –Ω–∞ —Ä–∞—Å—Å–º–æ—Ç—Ä–µ–Ω–∏–µ!");
    } catch (error) {
      console.error("Error submitting form:", error.message);
      ctx.reply("–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–ø—Ä–∞–≤–∫–µ –∞–Ω–∫–µ—Ç—ã. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ.");
    }
    delete userStates[userId];
  }
});

// –≠–∫—Å–ø–æ—Ä—Ç –¥–ª—è –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è –≤ server.js
module.exports = { bot, notifySubscribers };

// –ó–∞–ø—É—Å–∫ –±–æ—Ç–∞ —Ç–æ–ª—å–∫–æ –ø—Ä–∏ –ø—Ä—è–º–æ–º –≤—ã–∑–æ–≤–µ —Ñ–∞–π–ª–∞
if (require.main === module) {
  console.log("Starting bot...");
  bot.launch().then(() => console.log("Bot launched"));
}
